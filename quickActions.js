// quickActions.js
import * as Notifications from 'expo-notifications';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { activarSOSDesdeNotificacion } from './backgroundConfig';

// Configurar categor√≠as de notificaciones con acciones
export const configurarCategoriasNotificaciones = async () => {
  try {
    // Definir categor√≠a para acciones SOS
    await Notifications.setNotificationCategoryAsync('SOS_CATEGORY', [
      {
        identifier: 'SOS_ROBO',
        buttonTitle: 'üö® SOS Robo',
        options: {
          isDestructive: true,
          isAuthenticationRequired: false,
        },
      },
      {
        identifier: 'SOS_PINCHAZO',
        buttonTitle: 'üõ†Ô∏è SOS Pinchazo',
        options: {
          isDestructive: false,
          isAuthenticationRequired: false,
        },
      },
      {
        identifier: 'CANCELAR_SOS',
        buttonTitle: '‚ùå Cancelar',
        options: {
          isDestructive: false,
          isAuthenticationRequired: false,
        },
      },
    ]);
    
    // Definir categor√≠a para SOS activo con opci√≥n de cancelar
    await Notifications.setNotificationCategoryAsync('SOS_ACTIVO_CATEGORY', [
      {
        identifier: 'CANCELAR_SOS_ACTIVO',
        buttonTitle: '‚ùå Cancelar SOS',
        options: {
          isDestructive: false,
          isAuthenticationRequired: false,
        },
      },
    ]);
    
    console.log('Categor√≠as de notificaciones configuradas');
  } catch (error) {
    console.error('Error configurando categor√≠as:', error);
  }
};

// Funci√≥n para enviar notificaci√≥n con botones de acci√≥n
export const enviarNotificacionConAcciones = async () => {
  try {
    await Notifications.scheduleNotificationAsync({
      content: {
        title: "üö® Acceso R√°pido SOS",
        body: "Toca un bot√≥n para activar una alerta de emergencia",
        data: { type: 'sos_quick_actions' },
        sound: true,
        priority: Notifications.AndroidNotificationPriority.HIGH,
        categoryIdentifier: 'SOS_CATEGORY',
      },
      trigger: null,
    });
  } catch (error) {
    console.error('Error enviando notificaci√≥n con acciones:', error);
  }
};

// Funci√≥n para manejar respuestas de notificaciones
export const manejarRespuestaNotificacion = async (response) => {
  try {
    const { actionIdentifier, notification } = response;
    const { data } = notification.request.content;
    
    console.log('Respuesta de notificaci√≥n recibida:', { actionIdentifier, data });
    
    if (data?.type === 'sos_quick_actions' || data?.type === 'sos_quick_access') {
      switch (actionIdentifier) {
        case 'SOS_ROBO':
          console.log('Activando SOS Robo desde notificaci√≥n');
          await activarSOSDesdeNotificacion('robo');
          break;
        case 'SOS_PINCHAZO':
          console.log('Activando SOS Pinchazo desde notificaci√≥n');
          await activarSOSDesdeNotificacion('pinchazo');
          break;
        case 'CANCELAR_SOS':
          console.log('Cancelando SOS desde notificaci√≥n');
          // Cancelar cualquier SOS activo
          await AsyncStorage.setItem('sosActivo', 'false');
          await AsyncStorage.setItem('sosEnviado', 'true');
          break;
        default:
          console.log('Acci√≥n no reconocida:', actionIdentifier);
      }
    } else if (data?.type === 'sos_activo') {
      switch (actionIdentifier) {
        case 'CANCELAR_SOS_ACTIVO':
          console.log('Cancelando SOS activo desde notificaci√≥n');
          await cancelarSOSDesdeNotificacion();
          break;
        default:
          console.log('Acci√≥n no reconocida para SOS activo:', actionIdentifier);
      }
    }
  } catch (error) {
    console.error('Error manejando respuesta de notificaci√≥n:', error);
  }
};

// Funci√≥n para cancelar SOS desde notificaci√≥n
const cancelarSOSDesdeNotificacion = async () => {
  try {
    // Cancelar SOS
    await AsyncStorage.setItem('sosActivo', 'false');
    await AsyncStorage.setItem('sosEnviado', 'true');
    await AsyncStorage.setItem('sosCancelado', 'true');
    await AsyncStorage.setItem('sosCanceladoTimestamp', Date.now().toString());
    await AsyncStorage.removeItem('sosInicio');
    
    // Enviar notificaci√≥n de confirmaci√≥n
    await Notifications.scheduleNotificationAsync({
      content: {
        title: "‚úÖ SOS Cancelado",
        body: "La alerta de emergencia ha sido cancelada",
        data: { type: 'sos_cancelado' },
        sound: true,
        priority: Notifications.AndroidNotificationPriority.HIGH,
      },
      trigger: null,
    });
    
    console.log('SOS cancelado desde notificaci√≥n');
  } catch (error) {
    console.error('Error cancelando SOS desde notificaci√≥n:', error);
  }
};

// Funci√≥n para programar notificaciones peri√≥dicas de acceso r√°pido
export const programarNotificacionesPeriodicas = async () => {
  try {
    // Verificar si ya se programaron las notificaciones
    const notificacionesProgramadas = await AsyncStorage.getItem('notificacionesPeriodicasProgramadas');
    if (notificacionesProgramadas === 'true') {
      console.log('Notificaciones peri√≥dicas ya programadas');
      return;
    }
    
    // Enviar notificaci√≥n de acceso r√°pido cada 15 minutos cuando la app est√° en background
    await Notifications.scheduleNotificationAsync({
      content: {
        title: "üö® SOS R√°pido Disponible",
        body: "La app est√° lista para enviar alertas de emergencia",
        data: { type: 'sos_reminder' },
        sound: false, // Sin sonido para no molestar
        priority: Notifications.AndroidNotificationPriority.LOW,
        categoryIdentifier: 'SOS_CATEGORY',
      },
      trigger: {
        seconds: 900, // 15 minutos (aumentado de 5 a 15)
        repeats: true,
      },
    });
    
    // Marcar como programadas
    await AsyncStorage.setItem('notificacionesPeriodicasProgramadas', 'true');
    console.log('Notificaciones peri√≥dicas programadas cada 15 minutos');
  } catch (error) {
    console.error('Error programando notificaciones peri√≥dicas:', error);
  }
};

// Funci√≥n para activar SOS con gesto (simulado)
export const activarSOSConGesto = async (tipoGesto = 'doble_tap') => {
  try {
    let tipoSOS = 'robo'; // Por defecto
    
    // Simular diferentes tipos de gestos
    switch (tipoGesto) {
      case 'doble_tap':
        tipoSOS = 'robo';
        break;
      case 'triple_tap':
        tipoSOS = 'pinchazo';
        break;
      case 'long_press':
        tipoSOS = 'robo';
        break;
      default:
        tipoSOS = 'robo';
    }
    
    await activarSOSDesdeNotificacion(tipoSOS);
    console.log(`SOS ${tipoSOS} activado con gesto: ${tipoGesto}`);
  } catch (error) {
    console.error('Error activando SOS con gesto:', error);
  }
};

// Funci√≥n para configurar acceso r√°pido completo
export const configurarAccesoRapido = async () => {
  try {
    await configurarCategoriasNotificaciones();
    await programarNotificacionesPeriodicas();
    console.log('Acceso r√°pido SOS configurado');
  } catch (error) {
    console.error('Error configurando acceso r√°pido:', error);
  }
};

// Funci√≥n para probar SOS directamente desde background
export const probarSOSBackground = async () => {
  try {
    console.log('Probando SOS desde background...');
    
    // Enviar notificaci√≥n con acciones inmediatamente
    await Notifications.scheduleNotificationAsync({
      content: {
        title: "üö® PRUEBA SOS BACKGROUND",
        body: "Toca un bot√≥n para activar SOS sin abrir la app",
        data: { type: 'sos_quick_actions' },
        sound: true,
        priority: Notifications.AndroidNotificationPriority.HIGH,
        categoryIdentifier: 'SOS_CATEGORY',
      },
      trigger: null, // Enviar inmediatamente
    });
    
    console.log('Notificaci√≥n de prueba enviada');
  } catch (error) {
    console.error('Error enviando notificaci√≥n de prueba:', error);
  }
};
